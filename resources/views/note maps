<DOCUMENT filename="map.blade.php">
    @extends('layouts.app')

    @section('content')
        <div class="container mx-auto px-4 py-12 font-['Poppins']">
            <!-- Header -->
            <h1 class="text-4xl font-extrabold text-white mb-8 tracking-tight text-center">
                Peta Interaktif Sampah
            </h1>

            <!-- Search and Filter Section -->
            <div class="bg-[#0b1121]/70 backdrop-blur-md p-6 rounded-2xl mb-8 shadow-[0px_6px_20px_rgba(0,0,0,0.4)]">
                <div class="grid md:grid-cols-3 gap-6 mb-6">
                    <div>
                        <label for="location" class="block text-sm font-medium text-gray-300 mb-2">Lokasi</label>
                        <input type="text" id="location" name="location"
                            class="w-full px-4 py-3 rounded-xl bg-[#1e293b]/80 border border-gray-600 text-gray-200 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-cyan-400 transition duration-300"
                            placeholder="Cari lokasi...">
                    </div>
                    <div>
                        <label for="type" class="block text-sm font-medium text-gray-300 mb-2">Jenis Lokasi</label>
                        <div class="relative">
                            <select id="type" name="type"
                                class="w-full appearance-none pr-10 px-4 py-3 rounded-xl bg-[#1e293b]/80 border border-gray-600 text-gray-200 focus:outline-none focus:ring-2 focus:ring-cyan-400 transition duration-300">
                                <option value="">Semua</option>
                                <option value="organik">Organik</option>
                                <option value="anorganik">Anorganik</option>
                                <option value="b3">B3</option>
                                <option value="campuran">Campuran</option>
                            </select>
                            <div class="pointer-events-none absolute right-3 top-1/2 -translate-y-1/2 text-gray-400">
                                ‚ñº
                            </div>
                        </div>
                    </div>
                    <div>
                        <label for="radius" class="block text-sm font-medium text-gray-300 mb-2">Radius (km)</label>
                        <input type="number" id="radius" name="radius" min="1" max="50" value="10"
                            class="w-full px-4 py-3 rounded-xl bg-[#1e293b]/80 border border-gray-600 text-gray-200 focus:outline-none focus:ring-2 focus:ring-cyan-400 transition duration-300">
                    </div>
                </div>
                <button id="searchButton"
                    class="flex items-center justify-center gap-2 bg-gradient-to-r from-cyan-400 to-cyan-600 hover:from-cyan-500 hover:to-cyan-700 text-white px-6 py-3 rounded-xl transition duration-300 shadow-md font-semibold">
                    üîç Cari
                </button>
            </div>

            <!-- Map Container -->
            <div
                class="bg-[#d9d9d9]/10 rounded-xl overflow-hidden h-[700px] shadow-[0px_6px_20px_rgba(0,0,0,0.3)] relative">
                <div id="map" class="w-full h-full"></div>
                <!-- Custom Reset Button -->
                <button id="resetMapButton" class="custom-reset-button">
                    Reset Peta
                </button>
                <!-- Loading Indicator -->
                <div id="loadingIndicator"
                    class="absolute top-4 right-4 bg-gray-800 text-white px-3 py-1 rounded-lg text-sm hidden">
                    Memuat data...
                </div>
            </div>

            <!-- Information Section -->
            <div class="mt-16 grid grid-cols-1 md:grid-cols-3 gap-8">
                <!-- Nearest Locations -->
                <div class="bg-[#0b1121]/80 backdrop-blur-lg p-6 rounded-2xl shadow-xl">
                    <h3 class="text-2xl font-semibold text-white mb-5 flex items-center gap-2">
                        <svg class="w-6 h-6 text-[#22d3ee]" fill="none" stroke="currentColor" stroke-width="2"
                            viewBox="0 0 24 24">
                            <path d="M17.657 16.657L13.414 12l4.243-4.243M6.343 7.343L10.586 12l-4.243 4.243" />
                        </svg>
                        Lokasi Terdekat
                    </h3>
                    <ul id="nearest-locations" class="space-y-5 text-gray-300 text-sm">
                        <!-- Diisi dinamis oleh JavaScript -->
                    </ul>
                </div>

                <!-- Area Statistics -->
                <div class="bg-[#0b1121]/80 backdrop-blur-lg p-6 rounded-2xl shadow-xl">
                    <h3 class="text-2xl font-semibold text-white mb-5 flex items-center gap-2">
                        <svg class="w-6 h-6 text-[#22d3ee]" fill="none" stroke="currentColor" stroke-width="2"
                            viewBox="0 0 24 24">
                            <path d="M11 3v18m-4-4l4 4 4-4" />
                        </svg>
                        Statistik Area
                    </h3>
                    <div id="area-statistics" class="space-y-5">
                        <!-- Diisi dinamis oleh JavaScript -->
                    </div>
                </div>

                <!-- Report New Location -->
                <div class="bg-[#0b1121]/80 backdrop-blur-lg p-6 rounded-2xl shadow-xl flex flex-col justify-between">
                    <div>
                        <h3 class="text-2xl font-semibold text-white mb-5 flex items-center gap-2">
                            <svg class="w-6 h-6 text-[#22d3ee]" fill="none" stroke="currentColor" stroke-width="2"
                                viewBox="0 0 24 24">
                                <path d="M12 4v16m8-8H4" />
                            </svg>
                            Laporkan Titik Baru
                        </h3>
                        <p class="text-sm text-gray-300 mb-6 leading-relaxed">Temukan titik sampah liar yang belum
                            terpetakan? Laporkan sekarang untuk membantu lingkungan kita menjadi lebih bersih.</p>
                    </div>
                    <a href="{{ route('report') }}"
                        class="mt-auto bg-gradient-to-r from-[#22d3ee] to-[#06b6d4] hover:from-[#06b6d4] hover:to-[#0891b2] text-white px-6 py-3 rounded-lg inline-block transition duration-300 shadow-lg text-center font-medium">
                        Laporkan Titik Sampah
                    </a>
                </div>
            </div>
        </div>

        <!-- Leaflet CDN -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
        <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
        <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

        <style>
            /* Custom Map Styles to Match SIPSN */
            .leaflet-container {
                background: #f5f6f5 !important;
                border-radius: 12px;
            }

            .leaflet-control-container .leaflet-control {
                background: #ffffff !important;
                border-radius: 8px !important;
                padding: 4px !important;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
            }

            .leaflet-control-zoom a {
                background: #ffffff !important;
                color: #333333 !important;
                border-radius: 6px !important;
                width: 28px !important;
                height: 28px !important;
                line-height: 28px !important;
                font-size: 16px !important;
                transition: all 0.2s ease !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                margin: 2px !important;
                border: 1px solid #d1d5db !important;
            }

            .leaflet-control-zoom a:hover {
                background: #e5e7eb !important;
                color: #1e40af !important;
            }

            .leaflet-control-zoom {
                display: flex !important;
                flex-direction: column !important;
                gap: 4px !important;
                top: 10px !important;
                left: 10px !important;
            }

            .leaflet-control-attribution {
                background: #ffffff !important;
                color: #4b5563 !important;
                border-radius: 6px !important;
                font-size: 11px !important;
                padding: 2px 6px !important;
                bottom: 10px !important;
                right: 10px !important;
                opacity: 0.8;
            }

            .leaflet-popup-content-wrapper {
                background: #ffffff !important;
                border-radius: 8px !important;
                box-shadow: 0 3px 12px rgba(0, 0, 0, 0.2) !important;
                padding: 0 !important;
            }

            .leaflet-popup-content {
                margin: 12px !important;
                font-family: 'Poppins', sans-serif !important;
                font-size: 13px !important;
                max-width: 280px !important;
                line-height: 1.5 !important;
            }

            .leaflet-popup-tip {
                background: #ffffff !important;
            }

            .custom-reset-button {
                position: absolute;
                bottom: 15px;
                right: 15px;
                background: #ffffff !important;
                color: #1e40af !important;
                padding: 8px 16px;
                border-radius: 8px;
                border: 1px solid #d1d5db;
                font-size: 13px;
                font-weight: 500;
                cursor: pointer;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
                transition: all 0.2s ease;
            }

            .custom-reset-button:hover {
                background: #e5e7eb !important;
                color: #1e3a8a !important;
                transform: scale(1.03);
            }

            .marker-cluster-small {
                background: #f59e0b !important;
                border-radius: 50% !important;
                opacity: 0.9;
            }

            .marker-cluster-medium {
                background: #f59e0b !important;
                border-radius: 50% !important;
                opacity: 0.9;
            }

            .marker-cluster-large {
                background: #f59e0b !important;
                border-radius: 50% !important;
                opacity: 0.9;
            }

            .marker-cluster div {
                background: #ffffff !important;
                color: #1f2937 !important;
                font-weight: 600 !important;
                border-radius: 50% !important;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
                font-size: 12px;
            }

            /* Circle styles */
            .waste-circle {
                border-radius: 50%;
                opacity: 0.7;
                text-align: center;
                color: #fff;
                font-weight: bold;
                font-size: 14px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* Custom styles for waste circles with numbers */
            .waste-circle-label {
                position: absolute;
                color: white;
                font-weight: bold;
                font-size: 14px;
                text-align: center;
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                pointer-events: none;
            }

            /* Choropleth styles */
            .info {
                padding: 6px 8px;
                font: 14px/16px 'Poppins', Arial, Helvetica, sans-serif;
                background: white;
                background: rgba(255, 255, 255, 0.8);
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
                border-radius: 5px;
            }

            .info h4 {
                margin: 0 0 5px;
                color: #777;
                font-weight: 600;
            }

            .legend {
                line-height: 18px;
                color: #555;
            }

            .legend i {
                width: 18px;
                height: 18px;
                float: left;
                margin-right: 8px;
                opacity: 0.7;
            }

            /* Tooltip style */
            .leaflet-tooltip {
                font-family: 'Poppins', sans-serif;
                font-size: 12px;
                background: rgba(255, 255, 255, 0.9);
                border: 1px solid #ccc;
                border-radius: 4px;
                padding: 4px 8px;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            }
        </style>

        <script>
            // Fetch user-submitted waste points from the API
            async function fetchWastePoints() {
                const loadingIndicator = document.getElementById('loadingIndicator');
                loadingIndicator.classList.remove('hidden');

                try {
                    const response = await fetch('/api/reports', {
                        headers: {
                            'Accept': 'application/json',
                            'X-CSRF-TOKEN': '{{ csrf_token() }}'
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Gagal mengambil data laporan: ' + response.statusText);
                    }

                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        throw new Error('Respon bukan JSON yang valid');
                    }

                    const data = await response.json();
                    console.log('Raw API Response:', data); // Debug: Log raw response

                    if (!Array.isArray(data)) {
                        throw new Error('Data laporan tidak dalam format yang benar');
                    }

                    const processedData = data.map(report => {
                        let lat, lon;

                        // Check if coords array exists
                        if (report.coords && Array.isArray(report.coords) && report.coords.length === 2) {
                            lon = parseFloat(report.coords[0]);
                            lat = parseFloat(report.coords[1]);
                        } else {
                            // Fallback to latitude and longitude fields
                            lat = parseFloat(report.latitude);
                            lon = parseFloat(report.longitude);
                        }

                        return {
                            id: report.id || null,
                            name: report.name || 'Unknown',
                            coords: (!isNaN(lat) && !isNaN(lon)) ? [lat, lon] : null,
                            type: report.type || 'Unknown',
                            address: report.location || 'Unknown',
                            capacity: report.size || 'Unknown',
                            urgency: report.urgency || 'Unknown',
                            description: report.description || 'No description',
                            photos: report.photos && Array.isArray(report.photos) ? report.photos : [],
                            province: report.province || 'Unknown'
                        };
                    });

                    console.log('Processed Data:', processedData); // Debug: Log processed data
                    return processedData;
                } catch (error) {
                    console.error('Error fetching waste points:', error);
                    showError('Gagal memuat data laporan: ' + error.message);
                    return [];
                } finally {
                    loadingIndicator.classList.add('hidden');
                }
            }

            // Geocode address if coordinates are missing
            async function geocodeAddress(address) {
                try {
                    const response = await fetch(
                        `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(address)}&format=json&limit=1`, {
                            headers: {
                                'User-Agent': 'EcoTrack/1.0'
                            }
                        });

                    if (!response.ok) {
                        throw new Error('Gagal melakukan geocoding');
                    }

                    const data = await response.json();
                    if (data.length === 0) {
                        throw new Error('Alamat tidak ditemukan');
                    }

                    console.log(`Geocoded Address "${address}":`, data[0]); // Debug: Log geocoding result
                    return {
                        lat: parseFloat(data[0].lat),
                        lon: parseFloat(data[0].lon)
                    };
                } catch (error) {
                    console.error('Geocoding error for address:', address, error);
                    return null;
                }
            }

            // Compute centroid for a polygon or multipolygon
            function computeCentroid(geometry) {
                let coords = [];
                if (geometry.type === 'Polygon') {
                    coords = geometry.coordinates[0];
                } else if (geometry.type === 'MultiPolygon') {
                    let largestArea = 0;
                    let largestPolygon = null;
                    for (const polygon of geometry.coordinates) {
                        const area = polygon[0].reduce((sum, coord, idx, arr) => {
                            if (idx === arr.length - 1) return sum;
                            return sum + (coord[0] * arr[idx + 1][1] - arr[idx + 1][0] * coord[1]);
                        }, 0);
                        const absArea = Math.abs(area);
                        if (absArea > largestArea) {
                            largestArea = absArea;
                            largestPolygon = polygon[0];
                        }
                    }
                    coords = largestPolygon || geometry.coordinates[0][0];
                }

                if (!coords || coords.length === 0) {
                    return null;
                }

                let latSum = 0,
                    lonSum = 0;
                for (const coord of coords) {
                    lonSum += coord[0];
                    latSum += coord[1];
                }
                return L.latLng(latSum / coords.length, lonSum / coords.length);
            }

            // Function to show error messages
            function showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'absolute top-4 left-4 bg-red-600 text-white px-3 py-1 rounded-lg text-sm';
                errorDiv.textContent = message;
                document.getElementById('map').parentElement.appendChild(errorDiv);
                setTimeout(() => errorDiv.remove(), 3000);
            }

            // Initialize map
            function initializeMap() {
                const map = L.map('map', {
                    center: [-2.5489, 118.0149], // Center of Indonesia
                    zoom: 5,
                    minZoom: 3,
                    maxZoom: 18,
                    zoomControl: false
                });

                L.control.zoom({
                    position: 'topleft'
                }).addTo(map);

                const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                    tileSize: 256,
                    maxZoom: 18
                });

                const satelliteLayer = L.tileLayer(
                    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                        attribution: 'Tiles ¬© Esri ‚Äî Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
                        maxZoom: 18
                    });

                let defaultLayer = localStorage.getItem('mapLayer') === 'satellite' ? satelliteLayer : osmLayer;
                defaultLayer.addTo(map);

                const markers = L.markerClusterGroup({
                    maxClusterRadius: 60,
                    spiderfyOnMaxZoom: true,
                    showCoverageOnHover: true,
                    zoomToBoundsOnClick: true,
                    disableClusteringAtZoom: 14,
                    iconCreateFunction: function(cluster) {
                        const count = cluster.getChildCount();
                        let sizeClass = 'small';
                        if (count >= 10 && count < 100) sizeClass = 'medium';
                        else if (count >= 100) sizeClass = 'large';
                        return L.divIcon({
                            html: `<div><span>${count}</span></div>`,
                            className: `marker-cluster marker-cluster-${sizeClass}`,
                            iconSize: L.point(40, 40)
                        });
                    }
                });
                map.addLayer(markers);

                return {
                    map,
                    markers,
                    osmLayer,
                    satelliteLayer
                };
            }

            // Get custom marker icon based on type
            function getMarkerIcon(type) {
                let iconUrl;
                switch (type) {
                    case 'organik':
                        iconUrl = 'https://img.icons8.com/color/48/organic-food.png';
                        break;
                    case 'anorganik':
                        iconUrl = 'https://img.icons8.com/color/48/recycle.png';
                        break;
                    case 'b3':
                        iconUrl = 'https://img.icons8.com/color/48/hazard.png';
                        break;
                    case 'campuran':
                        iconUrl = 'https://img.icons8.com/color/48/waste.png';
                        break;
                    default:
                        iconUrl = 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png';
                }
                return L.icon({
                    iconUrl: iconUrl,
                    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [0, -41],
                    shadowSize: [41, 41],
                    shadowAnchor: [12, 41]
                });
            }

            // Update area statistics
            function updateAreaStatistics(wastePoints) {
                const types = ['organik', 'anorganik', 'b3', 'campuran'];
                const reportCounts = types.map(type => ({
                    label: type.charAt(0).toUpperCase() + type.slice(1),
                    count: wastePoints.filter(point => point.type.toLowerCase() === type).length,
                    unit: 'lokasi'
                }));
                const totalReports = wastePoints.length;

                const statsContainer = document.getElementById('area-statistics');
                statsContainer.innerHTML = '';

                reportCounts.forEach(({
                    label,
                    count,
                    unit
                }) => {
                    const statDiv = document.createElement('div');
                    statDiv.innerHTML = `
                    <p class="text-sm text-gray-300 mb-2">${label}</p>
                    <div class="w-full bg-gray-800 rounded-full h-3">
                        <div class="bg-gradient-to-r from-[#22d3ee] to-[#06b6d4] h-3 rounded-full transition-all duration-500"
                            style="width: ${totalReports > 0 ? (count / totalReports) * 100 : 0}%"></div>
                    </div>
                    <p class="text-right text-xs text-gray-400 mt-1">${count} ${unit}</p>
                `;
                    statsContainer.appendChild(statDiv);
                });
            }

            // Add markers to the map
            async function addMarkers(map, markers, filteredLocations, userLatLon) {
                markers.clearLayers();
                const nearestLocationsList = document.getElementById('nearest-locations');
                nearestLocationsList.innerHTML = '';

                const uniqueLocations = {};
                for (const loc of filteredLocations) {
                    // Skip if no coordinates and attempt geocoding
                    if (!loc.coords || isNaN(loc.coords[0]) || isNaN(loc.coords[1])) {
                        if (loc.address) {
                            const coords = await geocodeAddress(loc.address);
                            if (coords) {
                                loc.coords = [coords.lat, coords.lon];
                                console.log(`Geocoded coordinates for ${loc.name}:`, loc.coords); // Debug
                            } else {
                                console.warn('Cannot geocode address for:', loc.name, loc.address);
                                continue;
                            }
                        } else {
                            console.warn('Invalid coordinates and no address for:', loc.name, loc.coords);
                            continue;
                        }
                    }

                    const [lat, lon] = loc.coords;
                    const key = `${lat},${lon}`;
                    if (!uniqueLocations[key]) {
                        const distance = userLatLon ? calculateDistance(userLatLon[1], userLatLon[0], lon, lat) : 0;

                        const marker = L.marker([lat, lon], {
                            icon: getMarkerIcon(loc.type)
                        }).bindPopup(`
                        <div class="p-3">
                            <h4 class="font-bold text-gray-900 text-base mb-2">${loc.name}</h4>
                            <p class="text-gray-700 text-sm mb-1"><strong>Alamat:</strong> ${loc.address}</p>
                            <p class="text-gray-700 text-sm mb-1"><strong>Jenis:</strong> ${loc.type.charAt(0).toUpperCase() + loc.type.slice(1)}</p>
                            <p class="text-gray-700 text-sm mb-1"><strong>Ukuran:</strong> ${loc.capacity}</p>
                            <p class="text-gray-700 text-sm mb-1"><strong>Urgensi:</strong> ${loc.urgency}</p>
                            <p class="text-gray-700 text-sm mb-2"><strong>Deskripsi:</strong> ${loc.description}</p>
                            ${loc.photos.length > 0 ? '<p class="text-gray-700 text-sm mb-1"><strong>Foto:</strong></p>' + loc.photos.map(photo => `<img src="/storage/${photo}" alt="Waste Photo" class="w-full mt-1 rounded-md shadow-sm">`).join('') : ''}
                        </div>
                    `, {
                            className: 'popup-content',
                            autoPanPadding: [50, 50]
                        });
                        markers.addLayer(marker);
                        console.log(`Added marker for ${loc.name} at [${lat}, ${lon}]`); // Debug

                        const radius = parseInt(document.getElementById('radius').value);
                        if (!userLatLon || distance <= radius) {
                            const li = document.createElement('li');
                            li.className =
                                'border-b border-gray-200 pb-3 transition hover:bg-gray-100 rounded-md px-2 py-2 cursor-pointer';
                            li.innerHTML = `
                            <h4 class="font-semibold text-gray-900 text-sm">${loc.name}</h4>
                            <p class="text-gray-600 text-xs">${loc.address}</p>
                            <p class="text-gray-600 text-xs">Jenis: ${loc.type.charAt(0).toUpperCase() + loc.type.slice(1)}</p>
                            <p class="text-gray-600 text-xs">Ukuran: ${loc.capacity}</p>
                            <p class="text-gray-600 text-xs">Urgensi: ${loc.urgency}</p>
                            <p class="text-gray-600 text-xs">${distance.toFixed(1)} km dari lokasi Anda</p>
                        `;
                            li.addEventListener('click', () => {
                                map.setView([lat, lon], 14);
                                marker.openPopup();
                            });
                            nearestLocationsList.appendChild(li);
                        }
                        uniqueLocations[key] = true;
                    }
                }

                if (markers.getLayers().length > 0) {
                    map.fitBounds(markers.getBounds(), {
                        padding: [50, 50],
                        maxZoom: 14
                    });
                    console.log('Markers added to map:', markers.getLayers().length); // Debug
                } else {
                    console.warn('No valid locations to display on the map.');
                    showError('Tidak ada lokasi yang valid untuk ditampilkan.');
                }
            }

            // Calculate distance between two points
            function calculateDistance(lon1, lat1, lon2, lat2) {
                const R = 6371;
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            // Update map features (circles and markers based on zoom)
            function updateMapFeatures(map, markers, provinceReports, provinceCentroids, data) {
                const circleLayerGroup = L.layerGroup();
                circleLayerGroup.clearLayers();
                map.eachLayer(layer => {
                    if (layer instanceof L.Marker && layer !== markers) {
                        map.removeLayer(layer);
                    }
                });

                data.features.forEach(feature => {
                    const provinceName = feature.properties.NAME_1;
                    const reports = provinceReports[provinceName] || 0;
                    const centroid = provinceCentroids[provinceName];
                    if (!centroid) return;

                    if (map.getZoom() < 8) {
                        const circle = L.circle(centroid, {
                            ...getCircleOptions(reports),
                            fillOpacity: 0.5,
                            className: 'waste-circle'
                        });

                        const numberIcon = L.divIcon({
                            className: 'waste-circle-label',
                            html: `<span>${reports}</span>`,
                            iconSize: [40, 40],
                            iconAnchor: [20, 20]
                        });
                        const numberMarker = L.marker(centroid, {
                            icon: numberIcon
                        });

                        circle.bindTooltip(`<b>${provinceName}</b><br>${reports} laporan`, {
                            permanent: false,
                            className: 'leaflet-tooltip',
                            direction: 'center',
                            opacity: 0.9
                        }).bindPopup(`<b>${provinceName}</b><br>Jumlah Laporan: ${reports}`);

                        circleLayerGroup.addLayer(circle);
                        circleLayerGroup.addLayer(numberMarker);
                    } else {
                        const marker = L.marker(centroid, {
                                icon: getMarkerIcon()
                            })
                            .bindPopup(`<b>${provinceName}</b><br>Jumlah Laporan: ${reports}`);
                        marker.addTo(map);
                    }
                });

                circleLayerGroup.addTo(map);
            }

            // Get circle options based on report count
            function getCircleOptions(reports) {
                if (reports >= 16) return {
                    color: '#ff0000',
                    fillColor: '#ff0000',
                    radius: 60000
                }; // Red
                else if (reports >= 8) return {
                    color: '#ffa500',
                    fillColor: '#ffa500',
                    radius: 50000
                }; // Orange
                else return {
                    color: '#00ff00',
                    fillColor: '#00ff00',
                    radius: 40000
                }; // Green
            }

            // Initialize choropleth map
            function initializeChoropleth(map, provinceReports, data) {
                function getChoroplethColor(d) {
                    return d > 100 ? '#006837' :
                        d > 50 ? '#31a354' :
                        d > 20 ? '#78c679' :
                        d > 10 ? '#c2e699' :
                        d > 0 ? '#ffffcc' :
                        '#f7f7f7';
                }

                function style(feature) {
                    const reports = provinceReports[feature.properties.NAME_1] || 0;
                    return {
                        fillColor: getChoroplethColor(reports),
                        weight: 2,
                        opacity: 1,
                        color: 'white',
                        dashArray: '3',
                        fillOpacity: 0.7
                    };
                }

                function highlightFeature(e) {
                    const layer = e.target;
                    layer.setStyle({
                        weight: 5,
                        color: '#22d3ee',
                        dashArray: '',
                        fillOpacity: 0.7
                    });
                    if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) layer.bringToFront();
                    info.update(layer.feature.properties);
                    layer.openTooltip();
                }

                function resetHighlight(e) {
                    choroplethLayer.resetStyle(e.target);
                    info.update();
                    e.target.closeTooltip();
                }

                function zoomToFeature(e) {
                    map.fitBounds(e.target.getBounds());
                }

                function onEachFeature(feature, layer) {
                    const reports = provinceReports[feature.properties.NAME_1] || 0;
                    feature.properties.reports = reports;
                    layer.bindTooltip(
                        `<b>${feature.properties.NAME_1}</b><br>${reports} laporan`, {
                            sticky: true,
                            className: 'leaflet-tooltip',
                            opacity: 0.9
                        }
                    );

                    layer.on({
                        mouseover: highlightFeature,
                        mouseout: resetHighlight,
                        click: zoomToFeature
                    });
                }

                const choroplethLayer = L.geoJSON(data, {
                    style,
                    onEachFeature
                }).addTo(map);

                const info = L.control();
                info.onAdd = function(map) {
                    this._div = L.DomUtil.create('div', 'info');
                    this.update();
                    return this._div;
                };
                info.update = function(props) {
                    this._div.innerHTML = '<h4>Jumlah Laporan Sampah</h4>' + (props ?
                        '<b>' + props.NAME_1 + '</b><br />' + props.reports + ' laporan' :
                        'Arahkan kursor ke provinsi');
                };
                info.addTo(map);

                const legend = L.control({
                    position: 'bottomright'
                });
                legend.onAdd = function(map) {
                    const div = L.DomUtil.create('div', 'info legend'),
                        grades = [0, 10, 20, 50, 100],
                        labels = [];
                    for (let i = 0; i < grades.length; i++) {
                        div.innerHTML +=
                            '<i style="background:' + getChoroplethColor(grades[i] + 1) + '"></i> ' +
                            grades[i] + (grades[i + 1] ? '‚Äì' + grades[i + 1] + '<br>' : '+');
                    }
                    return div;
                };
                legend.addTo(map);

                return {
                    choroplethLayer,
                    info,
                    legend
                };
            }

            // Poll waste points for real-time updates
            function pollWastePoints(map, markers, userLatLon) {
                let lastWastePoints = [];
                return setInterval(async () => {
                    const wastePoints = await fetchWastePoints();
                    if (JSON.stringify(wastePoints) !== JSON.stringify(lastWastePoints)) {
                        lastWastePoints = wastePoints;
                        const type = document.getElementById('type').value;
                        const radius = parseInt(document.getElementById('radius').value);

                        let filteredLocations = wastePoints;
                        if (type) filteredLocations = wastePoints.filter(loc => loc.type.toLowerCase() === type);
                        if (userLatLon) filteredLocations = filteredLocations.filter(loc => {
                            const distance = calculateDistance(userLatLon[1], userLatLon[0], loc.coords[1],
                                loc.coords[0]);
                            return distance <= radius;
                        });

                        addMarkers(map, markers, filteredLocations, userLatLon);
                        updateAreaStatistics(filteredLocations);
                    }
                }, 5000); // Poll every 5 seconds
            }

            // Main initialization
            (async () => {
                const {
                    map,
                    markers,
                    osmLayer,
                    satelliteLayer
                } = initializeMap();
                let currentUserLatLon = null;

                let wastePoints = await fetchWastePoints();
                wastePoints = await Promise.all(wastePoints.map(async point => {
                    if (!point.coords || isNaN(point.coords[0]) || isNaN(point.coords[1])) {
                        if (point.address) {
                            const coords = await geocodeAddress(point.address);
                            if (coords) point.coords = [coords.lat, coords.lon];
                        }
                    }
                    return point;
                }));
                wastePoints = wastePoints.filter(point => point.coords && !isNaN(point.coords[0]) && !isNaN(point
                    .coords[1]));

                console.log('Processed Waste Points:', wastePoints); // Debug
                addMarkers(map, markers, wastePoints, null);
                updateAreaStatistics(wastePoints);

                const provinceReports = {};
                wastePoints.forEach(point => {
                    if (point.province && point.province !== 'Unknown') {
                        provinceReports[point.province] = (provinceReports[point.province] || 0) + 1;
                    }
                });

                fetch('{{ asset('storage/gadm41_IDN_1.json') }}')
                    .then(response => {
                        if (!response.ok) throw new Error('Failed to load GeoJSON');
                        return response.json();
                    })
                    .then(data => {
                        const provinceCentroids = {};
                        data.features.forEach(feature => {
                            const centroid = computeCentroid(feature.geometry);
                            if (centroid) provinceCentroids[feature.properties.NAME_1] = centroid;
                        });

                        updateMapFeatures(map, markers, provinceReports, provinceCentroids, data);
                        map.on('zoomend', () => updateMapFeatures(map, markers, provinceReports, provinceCentroids,
                            data));

                        const {
                            choroplethLayer,
                            info,
                            legend
                        } = initializeChoropleth(map, provinceReports, data);

                        const baseMaps = {
                            "Peta": osmLayer,
                            "Satelit": satelliteLayer
                        };
                        const overlayMaps = {
                            "Choropleth (Laporan per Provinsi)": choroplethLayer,
                            "Marker Laporan": markers
                        };
                        L.control.layers(baseMaps, overlayMaps).addTo(map);

                        map.on('overlayadd', e => {
                            if (e.name === 'Choropleth (Laporan per Provinsi)') {
                                info.addTo(map);
                                legend.addTo(map);
                            }
                        });
                        map.on('overlayremove', e => {
                            if (e.name === 'Choropleth (Laporan per Provinsi)') {
                                map.removeControl(info);
                                map.removeControl(legend);
                            }
                        });

                        map.on('baselayerchange', e => {
                            localStorage.setItem('mapLayer', e.name.toLowerCase());
                        });
                    })
                    .catch(error => console.error('Error loading GeoJSON:', error));

                const pollInterval = pollWastePoints(map, markers, currentUserLatLon);

                document.getElementById('searchButton').addEventListener('click', async () => {
                    const locationInput = document.getElementById('location').value;
                    const type = document.getElementById('type').value;
                    const radius = parseInt(document.getElementById('radius').value);

                    let userLatLon = null;
                    if (locationInput) {
                        const coords = await geocodeAddress(locationInput);
                        if (coords) {
                            userLatLon = [coords.lat, coords.lon];
                            currentUserLatLon = userLatLon;
                        } else {
                            showError('Tidak dapat menemukan koordinat untuk lokasi tersebut.');
                            return;
                        }
                    } else {
                        currentUserLatLon = null;
                    }

                    const wastePoints = await fetchWastePoints();
                    let filteredLocations = wastePoints;
                    if (type) filteredLocations = wastePoints.filter(loc => loc.type.toLowerCase() ===
                        type);
                    if (userLatLon) filteredLocations = filteredLocations.filter(loc => {
                        const distance = calculateDistance(userLatLon[1], userLatLon[0], loc.coords[
                            1], loc.coords[0]);
                        return distance <= radius;
                    });

                    addMarkers(map, markers, filteredLocations, userLatLon);
                    updateAreaStatistics(filteredLocations);
                });

                document.getElementById('resetMapButton').addEventListener('click', async () => {
                    map.setView([-2.5489, 118.0149], 5);
                    currentUserLatLon = null;
                    document.getElementById('location').value = '';
                    document.getElementById('type').value = '';
                    document.getElementById('radius').value = 10;
                    const wastePoints = await fetchWastePoints();
                    addMarkers(map, markers, wastePoints, null);
                    updateAreaStatistics(wastePoints);
                    map.closePopup();
                    clearInterval(pollInterval); // Stop polling
                    pollInterval = pollWastePoints(map, markers, currentUserLatLon); // Restart polling
                });
            })();
        </script>
    @endsection
</DOCUMENT>
 fetch('{{ asset('storage/gadm41_IDN_2.json') }}')